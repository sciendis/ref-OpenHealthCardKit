// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0.3 effective-5.10 (swiftlang-6.0.3.1.10 clang-1600.0.30.1)
// swift-module-flags: -target arm64-apple-ios17.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Onone -enable-experimental-feature OpaqueTypeErasure -enable-bare-slash-regex -module-name HealthCardAccess
// swift-module-flags-ignorable: -no-verify-emitted-module-interface
import ASN1Kit
import CardReaderProviderApi
import Combine
import Foundation
import Security
import Swift
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
public struct ApplicationIdentifier : HealthCardAccess.CardObjectIdentifierType {
  public enum Error : Swift.Error, Swift.Equatable {
    case illegalArgument(Swift.String)
    case invalidLength(length: Swift.Int)
    public static func == (a: HealthCardAccess.ApplicationIdentifier.Error, b: HealthCardAccess.ApplicationIdentifier.Error) -> Swift.Bool
  }
  public let rawValue: Foundation.Data
  public init(_ data: Foundation.Data) throws
  public init(hex text: Swift.String) throws
  public static func isValid(_ value: Foundation.Data) -> Swift.Result<Foundation.Data, any Swift.Error>
  public typealias StringLiteralType = Swift.StringLiteralType
}
extension HealthCardAccess.ApplicationIdentifier : Swift.CustomDebugStringConvertible, Swift.CustomStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
}
extension HealthCardAccess.ApplicationIdentifier {
  public typealias ExtendedGraphemeClusterLiteralType = HealthCardAccess.ApplicationIdentifier.StringLiteralType
  public typealias UnicodeScalarLiteralType = Swift.String
  public init(unicodeScalarLiteral value: HealthCardAccess.ApplicationIdentifier.UnicodeScalarLiteralType)
  public init(extendedGraphemeClusterLiteral value: HealthCardAccess.ApplicationIdentifier.ExtendedGraphemeClusterLiteralType)
  public init(stringLiteral value: Swift.StringLiteralType)
}
public struct CAN {
  public enum InvalidCAN : Swift.Error, Swift.Equatable {
    case illegalValue(Swift.Int, for: Swift.String, expected: Swift.Range<Swift.Int>)
    public static func == (a: HealthCardAccess.CAN.InvalidCAN, b: HealthCardAccess.CAN.InvalidCAN) -> Swift.Bool
  }
  public let rawValue: Foundation.Data
  public static func from(_ data: Foundation.Data) throws -> HealthCardAccess.CAN
}
public enum CardGeneration {
  case g1
  case g1P
  case g2
  case g2_1
  public static func parseCardGeneration(version: Swift.Int) -> HealthCardAccess.CardGeneration?
  public static func parseCardGeneration(data: Foundation.Data) -> HealthCardAccess.CardGeneration?
  public static func == (a: HealthCardAccess.CardGeneration, b: HealthCardAccess.CardGeneration) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension HealthCardAccess.CardGeneration : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public protocol CardItemType : Swift.Equatable {
}
public let dfSpecificPwdMarker: Swift.UInt8
public protocol CardKeyReferenceType {
  func calculateKeyReference(dfSpecific: Swift.Bool) -> Swift.UInt8
}
public protocol CardObjectIdentifierType : Swift.Equatable, Swift.ExpressibleByStringLiteral {
  var rawValue: Foundation.Data { get }
  static func isValid(_ value: Foundation.Data) -> Swift.Result<Foundation.Data, any Swift.Error>
}
extension HealthCardAccess.CardObjectIdentifierType {
  public static func == (lhs: Self, rhs: Self) -> Swift.Bool
}
public struct CardVersion2 {
  public enum Error : Swift.Error {
    case parseError(Swift.String)
  }
  public let fillingInstructionsVersion: Foundation.Data
  public let objectSystemVersion: Foundation.Data
  public let productIdentificationObjectSystemVersion: Foundation.Data
  public let fillingInstructionsEfGdoVersion: Foundation.Data
  public let fillingInstructionsEfAtrVersion: Foundation.Data
  public let fillingInstructionsEfKeyInfoVersion: Foundation.Data?
  public let fillingInstructionsEfEnvironmentSettingsVersion: Foundation.Data?
  public let fillingInstructionsEfLoggingVersion: Foundation.Data?
  public init(data: Foundation.Data) throws
  public func generation() -> HealthCardAccess.CardGeneration?
}
public typealias Signature = Foundation.Data
public typealias X509Certificate = Foundation.Data
public struct CertificateInfo {
  public let certificate: HealthCardAccess.X509Certificate
  public let signatureAlgorithm: HealthCardAccess.SignatureAlgorithm
  public init(certificate: HealthCardAccess.X509Certificate, signatureAlgorithm: HealthCardAccess.SignatureAlgorithm)
}
extension Foundation.Data {
  public func normalize(to targetByteCount: Swift.Int, paddingIndicator: Swift.UInt8 = 0x0) -> Foundation.Data
}
public struct DedicatedFile : HealthCardAccess.CardItemType {
  public let aid: HealthCardAccess.ApplicationIdentifier
  public let fid: HealthCardAccess.FileIdentifier?
  public init(aid: HealthCardAccess.ApplicationIdentifier, fid: HealthCardAccess.FileIdentifier? = nil)
  public static func == (a: HealthCardAccess.DedicatedFile, b: HealthCardAccess.DedicatedFile) -> Swift.Bool
}
public struct EgkFileSystem {
  public struct EF {
    public static let atr: HealthCardAccess.ElementaryFile
    public static let cardAccess: HealthCardAccess.ElementaryFile
    public static let cCaEgkCsE256: HealthCardAccess.ElementaryFile
    public static let cEgkAutCVCE256: HealthCardAccess.ElementaryFile
    public static let dir: HealthCardAccess.ElementaryFile
    public static let gdo: HealthCardAccess.ElementaryFile
    public static let version: HealthCardAccess.ElementaryFile
    public static let version2: HealthCardAccess.ElementaryFile
    public static let nfd: HealthCardAccess.ElementaryFile
    public static let hcaEinwilligung: HealthCardAccess.ElementaryFile
    public static let hcaGVD: HealthCardAccess.ElementaryFile
    public static let hcaLogging: HealthCardAccess.ElementaryFile
    public static let hcaPD: HealthCardAccess.ElementaryFile
    public static let hcaPruefungsnachweis: HealthCardAccess.ElementaryFile
    public static let hcaStandalone: HealthCardAccess.ElementaryFile
    public static let hcaStatusVD: HealthCardAccess.ElementaryFile
    public static let hcaTTN: HealthCardAccess.ElementaryFile
    public static let hcaVD: HealthCardAccess.ElementaryFile
    public static let hcaVerweis: HealthCardAccess.ElementaryFile
    public static let esignCChAutR2048: HealthCardAccess.ElementaryFile
    public static let esignCChAutE256: HealthCardAccess.ElementaryFile
    public static let esignCChAutnR2048: HealthCardAccess.ElementaryFile
    public static let esignCChEncR2048: HealthCardAccess.ElementaryFile
    public static let esignCChEncvR2048: HealthCardAccess.ElementaryFile
  }
  public struct DF {
    public static let MF: HealthCardAccess.DedicatedFile
    public static let HCA: HealthCardAccess.DedicatedFile
    public static let ESIGN: HealthCardAccess.DedicatedFile
    public static let QES: HealthCardAccess.DedicatedFile
    public static let NFD: HealthCardAccess.DedicatedFile
    public static let DPE: HealthCardAccess.DedicatedFile
    public static let GDD: HealthCardAccess.DedicatedFile
    public static let OSE: HealthCardAccess.DedicatedFile
    public static let AMTS: HealthCardAccess.DedicatedFile
  }
  public enum Pin : HealthCardAccess.Password {
    case pinCH
    case mrpinHome
    case mrpinNFD
    case mrpinNFDREAD
    case mrpinDPE
    case mrpinDPEREAD
    case mprinGDD
    case mrpinOSE
    case mrpinAMTS
    case pinAMTSREP
    case pinQES
    public var rawValue: HealthCardAccess.Password {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public init?(rawValue: HealthCardAccess.Password)
    public typealias RawValue = HealthCardAccess.Password
    public var hashValue: Swift.Int {
      get
    }
  }
}
public struct ElementaryFile : HealthCardAccess.CardItemType {
  public let fid: HealthCardAccess.FileIdentifier
  public let sfid: HealthCardAccess.ShortFileIdentifier?
  public init(fid: HealthCardAccess.FileIdentifier, sfid: HealthCardAccess.ShortFileIdentifier? = nil)
  public static func == (a: HealthCardAccess.ElementaryFile, b: HealthCardAccess.ElementaryFile) -> Swift.Bool
}
public struct FileControlParameter : HealthCardAccess.CardItemType {
  public enum LifeCycleState : Swift.Equatable {
    case unknown
    case creation
    case initialisation
    case activated
    case deactivated
    case terminated
    case proprietary
    public static func parseLifeCycle(byte: Swift.UInt8) -> HealthCardAccess.FileControlParameter.LifeCycleState?
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: HealthCardAccess.FileControlParameter.LifeCycleState, b: HealthCardAccess.FileControlParameter.LifeCycleState) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let tag: Swift.UInt
  public enum Tag : Swift.UInt {
    case numberOfOctets
    case fileDescriptor
    case fileIdentifier
    case applicationIdentifier
    case endOfFilePosition
    case shortFileIdentifier
    case lifeCycleStatus
    public init?(rawValue: Swift.UInt)
    public typealias RawValue = Swift.UInt
    public var rawValue: Swift.UInt {
      get
    }
  }
  public let status: HealthCardAccess.FileControlParameter.LifeCycleState
  public let size: Swift.UInt
  public let readSize: Swift.UInt?
  public let fileDescriptor: Swift.String?
  public let fileIdentifier: HealthCardAccess.FileIdentifier?
  public let applicationIdentifier: HealthCardAccess.ApplicationIdentifier?
  public let shortFileIdentifier: HealthCardAccess.ShortFileIdentifier?
  public init(status: HealthCardAccess.FileControlParameter.LifeCycleState, size: Swift.UInt, fileDescriptor: Swift.String?, fid: HealthCardAccess.FileIdentifier?, aid: HealthCardAccess.ApplicationIdentifier?, shortFid: HealthCardAccess.ShortFileIdentifier?, readSize: Swift.UInt?)
  public enum Error : Swift.Error, Swift.Equatable {
    case illegalArgument(Swift.String)
    case asn1ParseError(asn1: Foundation.Data, reason: Swift.String)
    case invalidCard(Swift.String)
    public static func == (a: HealthCardAccess.FileControlParameter.Error, b: HealthCardAccess.FileControlParameter.Error) -> Swift.Bool
  }
  public static func parse(data: Foundation.Data) throws -> HealthCardAccess.FileControlParameter
  public static func == (a: HealthCardAccess.FileControlParameter, b: HealthCardAccess.FileControlParameter) -> Swift.Bool
}
extension HealthCardAccess.FileControlParameter : Swift.CustomDebugStringConvertible, Swift.CustomStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
}
public struct FileIdentifier : HealthCardAccess.CardObjectIdentifierType {
  public enum Error : Swift.Error, Swift.Equatable {
    case illegalArgument(Swift.String)
    case invalidLength(length: Swift.Int)
    public static func == (a: HealthCardAccess.FileIdentifier.Error, b: HealthCardAccess.FileIdentifier.Error) -> Swift.Bool
  }
  public let rawValue: Foundation.Data
  public init(_ data: Foundation.Data) throws
  public init(hex text: Swift.String) throws
  public static func isValid(_ value: Foundation.Data) -> Swift.Result<Foundation.Data, any Swift.Error>
  public typealias StringLiteralType = Swift.StringLiteralType
}
extension HealthCardAccess.FileIdentifier : Swift.CustomDebugStringConvertible, Swift.CustomStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
}
extension HealthCardAccess.FileIdentifier {
  public typealias ExtendedGraphemeClusterLiteralType = HealthCardAccess.FileIdentifier.StringLiteralType
  public typealias UnicodeScalarLiteralType = Swift.String
  public init(stringLiteral value: Swift.StringLiteralType)
  public init(extendedGraphemeClusterLiteral value: HealthCardAccess.FileIdentifier.ExtendedGraphemeClusterLiteralType)
  public init(unicodeScalarLiteral value: HealthCardAccess.FileIdentifier.UnicodeScalarLiteralType)
}
public struct Format2Pin : HealthCardAccess.CardItemType {
  public enum Error : Swift.Error, Swift.Equatable {
    case illegalArgument(Swift.String)
    public static func == (a: HealthCardAccess.Format2Pin.Error, b: HealthCardAccess.Format2Pin.Error) -> Swift.Bool
  }
  public let pin: Foundation.Data
  public init(pincode: Swift.String) throws
  public static func == (a: HealthCardAccess.Format2Pin, b: HealthCardAccess.Format2Pin) -> Swift.Bool
}
extension HealthCardAccess.Format2Pin : Swift.ExpressibleByStringLiteral {
  public typealias ExtendedGraphemeClusterLiteralType = Swift.StringLiteralType
  public typealias UnicodeScalarLiteralType = Swift.String
  public init(stringLiteral value: Swift.StringLiteralType)
  public init(extendedGraphemeClusterLiteral value: HealthCardAccess.Format2Pin.ExtendedGraphemeClusterLiteralType)
  public init(unicodeScalarLiteral value: HealthCardAccess.Format2Pin.UnicodeScalarLiteralType)
  public typealias StringLiteralType = Swift.StringLiteralType
}
public struct GemCvCertificate {
  public enum Error : Swift.Error {
    case unexpected(tag: ASN1Kit.ASN1DecodedTag)
    case missing(tag: ASN1Kit.ASN1DecodedTag, source: any ASN1Kit.ASN1Object)
    case missingTagParameter
  }
  public let certificateBody: HealthCardAccess.CVCBody
  public let signature: Foundation.Data
  public static func from(asn1: any ASN1Kit.ASN1Object) throws -> HealthCardAccess.GemCvCertificate
  public static func from(data: Foundation.Data) throws -> HealthCardAccess.GemCvCertificate
  public struct Tag {
    public static let tag: ASN1Kit.ASN1DecodedTag
    public static let signature: ASN1Kit.ASN1DecodedTag
  }
}
extension HealthCardAccess.GemCvCertificate {
  public func asn1encode() throws -> Foundation.Data
}
extension HealthCardAccess.GemCvCertificate : Swift.Equatable {
  public static func == (a: HealthCardAccess.GemCvCertificate, b: HealthCardAccess.GemCvCertificate) -> Swift.Bool
}
public struct CVCBody {
  public let certificateProfileIdentifier: Foundation.Data
  public let certificateAuthorityReference: Foundation.Data
  public let publicKey: HealthCardAccess.CVCPublicKey
  public let certificateHolderReference: Foundation.Data
  public let certificateHolderAuthorization: HealthCardAccess.CVCChat
  public let certificateEffectiveDate: Foundation.Data
  public let certificateExpirationDate: Foundation.Data
  public let certificateExtensions: [Foundation.Data]
}
extension HealthCardAccess.CVCBody : Swift.Equatable {
  public static func == (a: HealthCardAccess.CVCBody, b: HealthCardAccess.CVCBody) -> Swift.Bool
}
extension HealthCardAccess.CVCBody : ASN1Kit.ASN1CodableType {
  public init(from asn1: any ASN1Kit.ASN1Object) throws
  public func asn1encode(tag: ASN1Kit.ASN1DecodedTag?) throws -> any ASN1Kit.ASN1Object
}
extension HealthCardAccess.CVCBody {
  public struct Tag {
    public static let tag: ASN1Kit.ASN1DecodedTag
    public static let cpi: ASN1Kit.ASN1DecodedTag
    public static let car: ASN1Kit.ASN1DecodedTag
    public static let pubKey: ASN1Kit.ASN1DecodedTag
    public static let chr: ASN1Kit.ASN1DecodedTag
    public static let chat: ASN1Kit.ASN1DecodedTag
    public static let ced: ASN1Kit.ASN1DecodedTag
    public static let cxd: ASN1Kit.ASN1DecodedTag
  }
  public static func from(asn1: any ASN1Kit.ASN1Object) throws -> HealthCardAccess.CVCBody
}
public struct CVCChat {
  public let terminalType: ASN1Kit.ObjectIdentifier
  public let relativeAuthorization: Foundation.Data
}
extension HealthCardAccess.CVCChat : Swift.Equatable {
  public static func == (a: HealthCardAccess.CVCChat, b: HealthCardAccess.CVCChat) -> Swift.Bool
}
extension HealthCardAccess.CVCChat : ASN1Kit.ASN1CodableType {
  public init(from asn1: any ASN1Kit.ASN1Object) throws
  public func asn1encode(tag: ASN1Kit.ASN1DecodedTag?) throws -> any ASN1Kit.ASN1Object
}
extension HealthCardAccess.CVCChat {
  public struct Tag {
    public static let oid: ASN1Kit.ASN1DecodedTag
    public static let content: ASN1Kit.ASN1DecodedTag
  }
  public static func from(asn1: any ASN1Kit.ASN1Object) throws -> HealthCardAccess.CVCChat
}
public struct CVCPublicKey {
  public let oid: ASN1Kit.ObjectIdentifier
  public let pubKey: Foundation.Data
}
extension HealthCardAccess.CVCPublicKey : Swift.Equatable {
  public static func == (a: HealthCardAccess.CVCPublicKey, b: HealthCardAccess.CVCPublicKey) -> Swift.Bool
}
extension HealthCardAccess.CVCPublicKey : ASN1Kit.ASN1CodableType {
  public init(from asn1: any ASN1Kit.ASN1Object) throws
  public func asn1encode(tag: ASN1Kit.ASN1DecodedTag?) throws -> any ASN1Kit.ASN1Object
}
extension HealthCardAccess.CVCPublicKey {
  public struct Tag {
    public static let oid: ASN1Kit.ASN1DecodedTag
    public static let content: ASN1Kit.ASN1DecodedTag
  }
  public static func from(asn1: any ASN1Kit.ASN1Object) throws -> HealthCardAccess.CVCPublicKey
}
public struct DHPubKey {
  public let oid: ASN1Kit.ObjectIdentifier
  public let prime: Foundation.Data
  public let subgroup: Foundation.Data
  public let generator: Foundation.Data
  public let value: Foundation.Data
}
extension HealthCardAccess.DHPubKey : Swift.Equatable {
  public static func == (a: HealthCardAccess.DHPubKey, b: HealthCardAccess.DHPubKey) -> Swift.Bool
}
public struct RSAPubKey {
  public let oid: ASN1Kit.ObjectIdentifier
  public let modulus: Foundation.Data
  public let exponent: Foundation.Data
}
extension HealthCardAccess.RSAPubKey : Swift.Equatable {
  public static func == (a: HealthCardAccess.RSAPubKey, b: HealthCardAccess.RSAPubKey) -> Swift.Bool
}
public struct ECDSAPubKey {
  public let oid: ASN1Kit.ObjectIdentifier
  public let modulus: Foundation.Data
  public let first: Foundation.Data
  public let second: Foundation.Data
  public let base: Foundation.Data
  public let order: Foundation.Data
  public let point: Foundation.Data
  public let cofactor: Foundation.Data
}
extension HealthCardAccess.ECDSAPubKey : Swift.Equatable {
  public static func == (a: HealthCardAccess.ECDSAPubKey, b: HealthCardAccess.ECDSAPubKey) -> Swift.Bool
}
public struct HbaFileSystem {
  public struct EF {
    public static let atr: HealthCardAccess.ElementaryFile
    public static let cardAccess: HealthCardAccess.ElementaryFile
    public static let dir: HealthCardAccess.ElementaryFile
    public static let gdo: HealthCardAccess.ElementaryFile
    public static let version2: HealthCardAccess.ElementaryFile
  }
  public struct DF {
    public static let MF: HealthCardAccess.DedicatedFile
    public static let HPA: HealthCardAccess.DedicatedFile
    public static let QES: HealthCardAccess.DedicatedFile
    public static let ESIGN: HealthCardAccess.DedicatedFile
    public static let CIAQES: HealthCardAccess.DedicatedFile
    public static let CIAESIGN: HealthCardAccess.DedicatedFile
    public static let AUTO: HealthCardAccess.DedicatedFile
  }
}
public class HealthCard : HealthCardAccess.HealthCardType {
  public var currentCardChannel: any CardReaderProviderApi.CardChannelType {
    get
  }
  public var status: HealthCardAccess.HealthCardStatus {
    get
  }
  public init(card: any CardReaderProviderApi.CardType, status: HealthCardAccess.HealthCardStatus = .unknown) throws
  public var channelNumber: Swift.Int {
    get
  }
  public var extendedLengthSupported: Swift.Bool {
    get
  }
  public var maxMessageLength: Swift.Int {
    get
  }
  public var maxResponseLength: Swift.Int {
    get
  }
  @objc deinit
}
extension HealthCardAccess.HealthCardCommand {
  public enum ActivateRecord {
    public static func activateRecord(shortFileIdentifier: HealthCardAccess.ShortFileIdentifier? = nil, recordNumber: Swift.UInt8, useAllFollowingRecords: Swift.Bool = false) throws -> HealthCardAccess.HealthCardCommand
  }
  public enum AppendRecord {
    public static func appendRecord(shortFileIdentifier: HealthCardAccess.ShortFileIdentifier? = nil, recordData: Foundation.Data) throws -> HealthCardAccess.HealthCardCommand
  }
  public enum DeactivateRecord {
    public static func deactivateRecord(shortFileIdentifier: HealthCardAccess.ShortFileIdentifier? = nil, recordNumber: Swift.UInt8, useAllFollowingRecords: Swift.Bool = false) throws -> HealthCardAccess.HealthCardCommand
  }
  public enum DeleteRecord {
    public static func deleteRecord(shortFileIdentifier: HealthCardAccess.ShortFileIdentifier? = nil, recordNumber: Swift.UInt8) throws -> HealthCardAccess.HealthCardCommand
  }
  public enum EraseRecord {
    public static func eraseRecord(shortFileIdentifier: HealthCardAccess.ShortFileIdentifier? = nil, recordNumber: Swift.UInt8) throws -> HealthCardAccess.HealthCardCommand
  }
  public enum ReadRecord {
    public static func readRecord(shortFileIdentifier: HealthCardAccess.ShortFileIdentifier? = nil, recordNumber: Swift.UInt8, expectedLength: Swift.Int) throws -> HealthCardAccess.HealthCardCommand
  }
  public enum SearchRecord {
    public static func searchRecord(shortFileIdentifier: HealthCardAccess.ShortFileIdentifier? = nil, recordNumber: Swift.UInt8, searchString: Foundation.Data, expectedLength: Swift.Int) throws -> HealthCardAccess.HealthCardCommand
  }
  public enum UpdateRecord {
    public static func updateRecord(shortFileIdentifier: HealthCardAccess.ShortFileIdentifier? = nil, recordNumber: Swift.UInt8, newData: Foundation.Data) throws -> HealthCardAccess.HealthCardCommand
  }
}
extension HealthCardAccess.HealthCardCommand {
  public enum Erase {
    public static func eraseFileCommand(offset: Swift.Int = 0) throws -> HealthCardAccess.HealthCardCommand
    public static func eraseFileCommand(with sfid: HealthCardAccess.ShortFileIdentifier, offset: Swift.Int = 0) throws -> HealthCardAccess.HealthCardCommand
  }
  public enum Read {
    public static func readFileCommand(ne: Swift.Int, offset: Swift.Int = 0) throws -> HealthCardAccess.HealthCardCommand
    public static func readFileCommand(with sfid: HealthCardAccess.ShortFileIdentifier, ne: Swift.Int, offset: Swift.Int = 0) throws -> HealthCardAccess.HealthCardCommand
  }
  public enum SetLogicalEof {
    public static func setLogicalEofCommand(offset: Swift.Int = 0) throws -> HealthCardAccess.HealthCardCommand
    public static func setLogicalEofCommand(with sfid: HealthCardAccess.ShortFileIdentifier, offset: Swift.Int = 0) throws -> HealthCardAccess.HealthCardCommand
  }
  public enum Update {
    public static func updateCommand(data: Foundation.Data, offset: Swift.Int = 0) throws -> HealthCardAccess.HealthCardCommand
    public static func updateCommand(with sfid: HealthCardAccess.ShortFileIdentifier, data: Foundation.Data, offset: Swift.Int = 0) throws -> HealthCardAccess.HealthCardCommand
  }
  public enum Write {
    public static func writeCommand(data: Foundation.Data) throws -> HealthCardAccess.HealthCardCommand
    public static func writeCommand(with sfid: HealthCardAccess.ShortFileIdentifier, data: Foundation.Data) throws -> HealthCardAccess.HealthCardCommand
  }
}
extension HealthCardAccess.HealthCardCommand {
  public enum Authentication {
    public static func externalMutualAuthentication(_ cmdData: Foundation.Data, expectResponse flag: Swift.Bool = false) throws -> HealthCardAccess.HealthCardCommand
    public static func internalAuthenticate(_ token: Foundation.Data) throws -> HealthCardAccess.HealthCardCommand
  }
  public enum ELC {
    public static func step1a(keyRef: Foundation.Data) throws -> HealthCardAccess.HealthCardCommand
    public static func step2a(ephemeralPK: Foundation.Data) throws -> HealthCardAccess.HealthCardCommand
    public static func step1b() -> HealthCardAccess.HealthCardCommand
    public static func step2b(cmd data: Foundation.Data) throws -> HealthCardAccess.HealthCardCommand
  }
  public enum PACE {
    public static func step1a() -> HealthCardAccess.HealthCardCommand
    public static func step2a(publicKey: Foundation.Data) throws -> HealthCardAccess.HealthCardCommand
    public static func step3a(publicKey: Foundation.Data) throws -> HealthCardAccess.HealthCardCommand
    public static func step4a(token: Foundation.Data) throws -> HealthCardAccess.HealthCardCommand
    public static func step1b() -> HealthCardAccess.HealthCardCommand
    public static func step2b(z: Foundation.Data, can: HealthCardAccess.CAN) throws -> HealthCardAccess.HealthCardCommand
    public static func step3b(publicKey: Foundation.Data) throws -> HealthCardAccess.HealthCardCommand
    public static func step4b(publicKey: Foundation.Data) throws -> HealthCardAccess.HealthCardCommand
    public static func step5b(token: Foundation.Data) throws -> HealthCardAccess.HealthCardCommand
  }
  public enum SecurityStatus {
    public static func readStatusFor(symmetricKey: HealthCardAccess.Key, dfSpecific: Swift.Bool) throws -> HealthCardAccess.HealthCardCommand
    public static func readStatusFor(rsaCvc key: Foundation.Data) throws -> HealthCardAccess.HealthCardCommand
    public static func readStatusFor(bitList flags: Foundation.Data, oid: ASN1Kit.ObjectIdentifier) throws -> HealthCardAccess.HealthCardCommand
  }
}
extension HealthCardAccess.HealthCardCommand {
  public enum ManageSE {
    public static func setEnvironment(number: Swift.Int) throws -> HealthCardAccess.HealthCardCommand
    public static func selectInternal(symmetricKey: HealthCardAccess.Key, dfSpecific: Swift.Bool, algorithm: HealthCardAccess.PSOAlgorithm) throws -> HealthCardAccess.HealthCardCommand
    public static func selectInternal(asymmetricKey: HealthCardAccess.Key, dfSpecific: Swift.Bool, algorithm: HealthCardAccess.PSOAlgorithm) throws -> HealthCardAccess.HealthCardCommand
    public static func selectExternal(symmetricKey: HealthCardAccess.Key, dfSpecific: Swift.Bool, algorithm: HealthCardAccess.PSOAlgorithm) throws -> HealthCardAccess.HealthCardCommand
    public static func selectExternal(referenceKey: Foundation.Data, algorithm: HealthCardAccess.PSOAlgorithm) throws -> HealthCardAccess.HealthCardCommand
    public static func selectMutual(symmetricKey: HealthCardAccess.Key, dfSpecific: Swift.Bool, algorithm: HealthCardAccess.PSOAlgorithm) throws -> HealthCardAccess.HealthCardCommand
    public static func selectPACE(symmetricKey: HealthCardAccess.Key, dfSpecific: Swift.Bool, oid: ASN1Kit.ObjectIdentifier) throws -> HealthCardAccess.HealthCardCommand
    public enum DomainId : Swift.UInt8 {
      case brainpoolP256r1
      case brainpoolP384r1
      case brainpoolP512r1
      public init?(rawValue: Swift.UInt8)
      public typealias RawValue = Swift.UInt8
      public var rawValue: Swift.UInt8 {
        get
      }
    }
    public static func selectPACE(symmetricKey: HealthCardAccess.Key, dfSpecific: Swift.Bool, oid: ASN1Kit.ObjectIdentifier, domain: HealthCardAccess.HealthCardCommand.ManageSE.DomainId) throws -> HealthCardAccess.HealthCardCommand
    public static func selectSigning(key: HealthCardAccess.Key, dfSpecific: Swift.Bool, algorithm: HealthCardAccess.PSOAlgorithm) throws -> HealthCardAccess.HealthCardCommand
    public static func selectCVC(referenceKey: Foundation.Data) throws -> HealthCardAccess.HealthCardCommand
    public static func selectDecipher(key: HealthCardAccess.Key, dfSpecific: Swift.Bool, algorithm: HealthCardAccess.PSOAlgorithm) throws -> HealthCardAccess.HealthCardCommand
    public static func selectEncipher(key: Foundation.Data, algorithm: HealthCardAccess.PSOAlgorithm) throws -> HealthCardAccess.HealthCardCommand
  }
}
extension HealthCardAccess.HealthCardCommand {
  public enum Misc {
    public static func fingerprint(for prefix: Foundation.Data) throws -> HealthCardAccess.HealthCardCommand
    public enum GenerationMode {
      case readOnly(reference: HealthCardAccess.Key?, dfSpecific: Swift.Bool)
      case generate(reference: HealthCardAccess.Key?, dfSpecific: Swift.Bool, overwrite: Swift.Bool, out: Swift.Bool)
    }
    public static func generateAsymmetricKeyPair(mode: HealthCardAccess.HealthCardCommand.Misc.GenerationMode) -> HealthCardAccess.HealthCardCommand
    public enum ChallengeParameter {
      case aes
      case des
      case elc
      case rsa
      public static func == (a: HealthCardAccess.HealthCardCommand.Misc.ChallengeParameter, b: HealthCardAccess.HealthCardCommand.Misc.ChallengeParameter) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public static func challenge(mode: HealthCardAccess.HealthCardCommand.Misc.ChallengeParameter) -> HealthCardAccess.HealthCardCommand
    public static func random(length: Swift.Int) throws -> HealthCardAccess.HealthCardCommand
    public static func listPublicKeys() -> HealthCardAccess.HealthCardCommand
    public static func openLogicChannel() -> HealthCardAccess.HealthCardCommand
    public static func closeLogicChannel(number: Swift.UInt8) -> HealthCardAccess.HealthCardCommand
    public static func resetLogicChannel(number: Swift.UInt8) -> HealthCardAccess.HealthCardCommand
    public static func resetApplication() -> HealthCardAccess.HealthCardCommand
  }
}
extension HealthCardAccess.HealthCardCommand {
  public enum Activate {
    public static func activateCurrentFile() -> HealthCardAccess.HealthCardCommand
    public static func activate(privateOrSymmetricKey: HealthCardAccess.Key, dfSpecific: Swift.Bool) -> HealthCardAccess.HealthCardCommand
    public static func activatePublicKey(reference: Foundation.Data) throws -> HealthCardAccess.HealthCardCommand
    public static func activate(password: HealthCardAccess.Password, dfSpecific: Swift.Bool) -> HealthCardAccess.HealthCardCommand
  }
  public enum Deactivate {
    public static func deactivateCurrentFile() -> HealthCardAccess.HealthCardCommand
    public static func deactivate(privateOrSymmetricKey: HealthCardAccess.Key, dfSpecific: Swift.Bool) -> HealthCardAccess.HealthCardCommand
    public static func deactivatePublicKey(reference: Foundation.Data) throws -> HealthCardAccess.HealthCardCommand
    public static func deactivate(password: HealthCardAccess.Password, dfSpecific: Swift.Bool) -> HealthCardAccess.HealthCardCommand
  }
  public enum Delete {
    public static func deleteCurrentFile() -> HealthCardAccess.HealthCardCommand
    public static func delete(privateOrSymmetricKey: HealthCardAccess.Key, dfSpecific: Swift.Bool) -> HealthCardAccess.HealthCardCommand
    public static func deletePublicKey(reference: Foundation.Data) throws -> HealthCardAccess.HealthCardCommand
    public static func delete(password: HealthCardAccess.Password, dfSpecific: Swift.Bool) -> HealthCardAccess.HealthCardCommand
  }
  public enum LoadApplication {
    public static func loadApplication(useChaining: Swift.Bool, data: Foundation.Data) -> HealthCardAccess.HealthCardCommand
  }
  public enum Select {
    public static func selectRoot() -> HealthCardAccess.HealthCardCommand
    public static func selectRootRequestingFcp(expectedLength: Swift.Int) throws -> HealthCardAccess.HealthCardCommand
    public static func selectFile(with aid: HealthCardAccess.ApplicationIdentifier, next occurrence: Swift.Bool = false) -> HealthCardAccess.HealthCardCommand
    public static func selectFileRequestingFcp(with aid: HealthCardAccess.ApplicationIdentifier, expectedLength: Swift.Int, next occurrence: Swift.Bool = false) throws -> HealthCardAccess.HealthCardCommand
    public static func selectDf(with fid: HealthCardAccess.FileIdentifier) -> HealthCardAccess.HealthCardCommand
    public static func selectDfRequestingFcp(with fid: HealthCardAccess.FileIdentifier, expectedLength: Swift.Int) throws -> HealthCardAccess.HealthCardCommand
    public static func selectParent() -> HealthCardAccess.HealthCardCommand
    public static func selectParentRequestingFcp(expectedLength: Swift.Int) throws -> HealthCardAccess.HealthCardCommand
    public static func selectEf(with fid: HealthCardAccess.FileIdentifier) -> HealthCardAccess.HealthCardCommand
    public static func selectEfRequestingFcp(with fid: HealthCardAccess.FileIdentifier, expectedLength: Swift.Int) throws -> HealthCardAccess.HealthCardCommand
  }
  public enum TerminateCardUsage {
    public static func terminateCardUsage() -> HealthCardAccess.HealthCardCommand
  }
  public enum TerminateDf {
    public static func terminateDf() -> HealthCardAccess.HealthCardCommand
  }
  public enum Terminate {
    public static func terminateCurrentFile() -> HealthCardAccess.HealthCardCommand
    public static func terminate(privateOrSymmetricKey: HealthCardAccess.Key, dfSpecific: Swift.Bool) -> HealthCardAccess.HealthCardCommand
    public static func terminatePublicKey(reference: Foundation.Data) throws -> HealthCardAccess.HealthCardCommand
    public static func terminate(password: HealthCardAccess.Password, dfSpecific: Swift.Bool) -> HealthCardAccess.HealthCardCommand
  }
}
extension HealthCardAccess.HealthCardCommand {
  public static let expectedLengthWildcard: Swift.Int
  public enum PsoChecksum {
    public static func hashUsingAES(incrementSSCmac flag: Swift.Bool, data: Foundation.Data) throws -> HealthCardAccess.HealthCardCommand
    public static func hashUsingDES(data: Foundation.Data) throws -> HealthCardAccess.HealthCardCommand
    public static func verify(data: Foundation.Data, mac hash: Foundation.Data) throws -> HealthCardAccess.HealthCardCommand
  }
  public enum PsoDSA {
    public static func sign(_ data: Foundation.Data) throws -> HealthCardAccess.HealthCardCommand
    public static func verify(signature: Foundation.Data, hash: Foundation.Data, publicKey: Security.SecKey) throws -> HealthCardAccess.HealthCardCommand
  }
  public enum PsoDecipher {
    public static func decipherUsingRsa(cryptogram: Foundation.Data) throws -> HealthCardAccess.HealthCardCommand
    public static func decipherUsingElc(cryptogram: Foundation.Data) throws -> HealthCardAccess.HealthCardCommand
    public static func decipherUsingSymmetricKey(cryptogram: Foundation.Data) throws -> HealthCardAccess.HealthCardCommand
  }
  public enum PsoEncipher {
    public static func encipherUsingTransmittedRsaKeyPkcs1_v1_5(rsaPublicKey: Security.SecKey, data: Foundation.Data) throws -> HealthCardAccess.HealthCardCommand
    public static func encipherUsingTransmittedRsaKeyOaep(rsaPublicKey: Security.SecKey, data: Foundation.Data) throws -> HealthCardAccess.HealthCardCommand
    public static func encipherUsingTransmittedElcKey(elcPublicKey: Security.SecKey, data: Foundation.Data) throws -> HealthCardAccess.HealthCardCommand
    public static func encipherUsingRsaKeyOnCard(data: Foundation.Data) throws -> HealthCardAccess.HealthCardCommand
    public static func encipherUsingElcKeyOnCard(data: Foundation.Data) throws -> HealthCardAccess.HealthCardCommand
    public static func encipherUsingSymmetricKeyOnCard(data: Foundation.Data) throws -> HealthCardAccess.HealthCardCommand
  }
  public enum PsoCertificate {
    public static func verify(cvc certificate: HealthCardAccess.GemCvCertificate) throws -> HealthCardAccess.HealthCardCommand
  }
}
extension HealthCardAccess.HealthCardCommand {
  public enum ChangeReferenceData {
    public typealias ChangePasswordParameter = (password: HealthCardAccess.Password, dfSpecific: Swift.Bool, old: HealthCardAccess.Format2Pin, new: HealthCardAccess.Format2Pin)
    public static func change(password parameter: HealthCardAccess.HealthCardCommand.ChangeReferenceData.ChangePasswordParameter) throws -> HealthCardAccess.HealthCardCommand
    public typealias SetPasswordParameter = (password: HealthCardAccess.Password, dfSpecific: Swift.Bool, pin: HealthCardAccess.Format2Pin)
    public static func set(password parameter: HealthCardAccess.HealthCardCommand.ChangeReferenceData.SetPasswordParameter) -> HealthCardAccess.HealthCardCommand
  }
  public enum DisableVerificationRequirement {
    public typealias VerificationRequirementPasswordParameter = (password: HealthCardAccess.Password, dfSpecific: Swift.Bool, verificationData: HealthCardAccess.Format2Pin?)
    public static func disable(password parameter: HealthCardAccess.HealthCardCommand.DisableVerificationRequirement.VerificationRequirementPasswordParameter) throws -> HealthCardAccess.HealthCardCommand
  }
  public enum EnableVerificationRequirement {
    public typealias VerificationRequirementPasswordParameter = (password: HealthCardAccess.Password, dfSpecific: Swift.Bool, verificationData: HealthCardAccess.Format2Pin?)
    public static func enable(password parameter: HealthCardAccess.HealthCardCommand.EnableVerificationRequirement.VerificationRequirementPasswordParameter) throws -> HealthCardAccess.HealthCardCommand
  }
  public enum Status {
    public typealias GetPinStatusParameter = (password: HealthCardAccess.Password, dfSpecific: Swift.Bool)
    public static func status(for parameter: HealthCardAccess.HealthCardCommand.Status.GetPinStatusParameter) -> HealthCardAccess.HealthCardCommand
  }
  public enum ResetRetryCounter {
    public static func resetRetryCounterWithPukWithNewSecret(password: HealthCardAccess.Password, dfSpecific: Swift.Bool, puk: HealthCardAccess.Format2Pin, newPin: HealthCardAccess.Format2Pin) throws -> HealthCardAccess.HealthCardCommand
    public static func resetRetryCounterWithPukWithoutNewSecret(password: HealthCardAccess.Password, dfSpecific: Swift.Bool, puk: HealthCardAccess.Format2Pin) throws -> HealthCardAccess.HealthCardCommand
    public static func resetRetryCounterWithoutPukWithNewSecret(password: HealthCardAccess.Password, dfSpecific: Swift.Bool, newPin: HealthCardAccess.Format2Pin) throws -> HealthCardAccess.HealthCardCommand
    public static func resetRetryCounterWithoutPukWithoutNewSecret(password: HealthCardAccess.Password, dfSpecific: Swift.Bool) throws -> HealthCardAccess.HealthCardCommand
  }
  public enum Verify {
    public typealias VerifyPasswordParameter = (password: HealthCardAccess.Password, dfSpecific: Swift.Bool, pin: HealthCardAccess.Format2Pin)
    public static func verify(password parameter: HealthCardAccess.HealthCardCommand.Verify.VerifyPasswordParameter) -> HealthCardAccess.HealthCardCommand
  }
}
public struct HealthCardCommand {
  public let apduCommand: any CardReaderProviderApi.CommandType
  public let responseStatuses: [Swift.UInt16 : HealthCardAccess.ResponseStatus]
}
extension HealthCardAccess.HealthCardCommand : HealthCardAccess.HealthCardCommandType {
  public var data: Foundation.Data? {
    get
  }
  public var ne: Swift.Int? {
    get
  }
  public var nc: Swift.Int {
    get
  }
  public var cla: Swift.UInt8 {
    get
  }
  public var ins: Swift.UInt8 {
    get
  }
  public var p1: Swift.UInt8 {
    get
  }
  public var p2: Swift.UInt8 {
    get
  }
  public var bytes: Foundation.Data {
    get
  }
}
public class HealthCardCommandBuilder {
  public init(cla: Swift.UInt8, ins: Swift.UInt8, p1: Swift.UInt8, p2: Swift.UInt8, data: Foundation.Data? = nil, ne: Swift.Int? = nil, responseStatuses: [Swift.UInt16 : HealthCardAccess.ResponseStatus])
  convenience public init()
  public func build() throws -> HealthCardAccess.HealthCardCommand
  public static func builder(from healthCardCommand: HealthCardAccess.HealthCardCommand) -> HealthCardAccess.HealthCardCommandBuilder
  public func set(cla: Swift.UInt8) -> HealthCardAccess.HealthCardCommandBuilder
  public func set(ins: Swift.UInt8) -> HealthCardAccess.HealthCardCommandBuilder
  public func set(p1: Swift.UInt8) -> HealthCardAccess.HealthCardCommandBuilder
  public func set(p2: Swift.UInt8) -> HealthCardAccess.HealthCardCommandBuilder
  public func set(data: Foundation.Data?) -> HealthCardAccess.HealthCardCommandBuilder
  public func add(data: Foundation.Data) -> HealthCardAccess.HealthCardCommandBuilder
  public func set(ne: Swift.Int?) -> HealthCardAccess.HealthCardCommandBuilder
  public func set(responseStatuses: [Swift.UInt16 : HealthCardAccess.ResponseStatus]) -> HealthCardAccess.HealthCardCommandBuilder
  @objc deinit
}
extension HealthCardAccess.HealthCardCommandBuilder {
  public static let sfidMarker: Swift.UInt8
  public enum InvalidArgument : Swift.Error, Swift.Equatable {
    case offsetOutOfBounds(Swift.Int, usingShortFileIdentifier: Swift.Bool)
    case recordDataSizeOutOfBounds(Foundation.Data)
    case expectedLengthMustNotBeZero
    case expectedLengthNotAWildcardValue(Swift.Int)
    case wrongMACLength(Swift.Int)
    case wrongHashLength(Swift.Int, expected: Swift.Int)
    case wrongSignatureLength(Swift.Int, expected: Swift.Int)
    case unsupportedKey(Security.SecKey)
    case illegalSize(Swift.Int, expected: Swift.Int)
    case illegalValue(Swift.Int, for: Swift.String, expected: Swift.Range<Swift.Int>)
    case illegalOid(ASN1Kit.ObjectIdentifier)
    public static func == (a: HealthCardAccess.HealthCardCommandBuilder.InvalidArgument, b: HealthCardAccess.HealthCardCommandBuilder.InvalidArgument) -> Swift.Bool
  }
}
public protocol HealthCardCommandType : CardReaderProviderApi.CommandType {
  var responseStatuses: [Swift.UInt16 : HealthCardAccess.ResponseStatus] { get }
}
extension HealthCardAccess.HealthCardCommandType {
  public func responseStatus(from code: Swift.UInt16) -> HealthCardAccess.ResponseStatus
  @available(*, deprecated, message: "Use structured concurrency version instead")
  public func publisher(for card: any HealthCardAccess.HealthCardType, writeTimeout: Foundation.TimeInterval = 0, readTimeout: Foundation.TimeInterval = 0) -> Combine.AnyPublisher<any HealthCardAccess.HealthCardResponseType, any Swift.Error>
  @available(*, deprecated, renamed: "transmit(to:writeTimeout:readTimeout:)")
  public func transmitAsync(to card: any HealthCardAccess.HealthCardType, writeTimeout: Foundation.TimeInterval = 0, readTimeout: Foundation.TimeInterval = 0) async throws -> any HealthCardAccess.HealthCardResponseType
  @available(*, deprecated, message: "Use structured concurrency version instead")
  public func publisher(for channel: any CardReaderProviderApi.CardChannelType, writeTimeout: Foundation.TimeInterval = 0, readTimeout: Foundation.TimeInterval = 0) -> Combine.AnyPublisher<any HealthCardAccess.HealthCardResponseType, any Swift.Error>
  @available(*, deprecated, renamed: "transmit(on:writeTimeout:readTimeout:)")
  public func transmitAsync(on channel: any CardReaderProviderApi.CardChannelType, writeTimeout: Foundation.TimeInterval = 0, readTimeout: Foundation.TimeInterval = 0) async throws -> any HealthCardAccess.HealthCardResponseType
}
extension HealthCardAccess.HealthCardCommandType {
  public func transmit(to card: any HealthCardAccess.HealthCardType, writeTimeout: Foundation.TimeInterval = 0, readTimeout: Foundation.TimeInterval = 0) async throws -> any HealthCardAccess.HealthCardResponseType
  public func transmit(on channel: any CardReaderProviderApi.CardChannelType, writeTimeout: Foundation.TimeInterval = 0, readTimeout: Foundation.TimeInterval = 0) async throws -> any HealthCardAccess.HealthCardResponseType
}
public protocol HealthCardFileSystemType {
  associatedtype CardFileSystem
}
public enum HealthCardPropertyType {
  case egk(generation: HealthCardAccess.CardGeneration)
  case hba(generation: HealthCardAccess.CardGeneration)
  case smcb(generation: HealthCardAccess.CardGeneration)
  public var generation: HealthCardAccess.CardGeneration {
    get
  }
}
extension HealthCardAccess.HealthCardPropertyType : Swift.Equatable {
  public static func == (lhs: HealthCardAccess.HealthCardPropertyType, rhs: HealthCardAccess.HealthCardPropertyType) -> Swift.Bool
}
extension HealthCardAccess.HealthCardPropertyType : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct HealthCardResponse {
  public init(response: any CardReaderProviderApi.ResponseType, responseStatus: HealthCardAccess.ResponseStatus)
  public let response: any CardReaderProviderApi.ResponseType
  public let responseStatus: HealthCardAccess.ResponseStatus
}
extension HealthCardAccess.HealthCardResponse : HealthCardAccess.HealthCardResponseType {
  public var data: Foundation.Data? {
    get
  }
  public var nr: Swift.Int {
    get
  }
  public var sw1: Swift.UInt8 {
    get
  }
  public var sw2: Swift.UInt8 {
    get
  }
  public var sw: Swift.UInt16 {
    get
  }
}
public protocol HealthCardResponseType : CardReaderProviderApi.ResponseType {
  var responseStatus: HealthCardAccess.ResponseStatus { get }
}
public enum HealthCardStatus {
  case unknown
  case valid(cardType: HealthCardAccess.HealthCardPropertyType?)
  case invalid
  public var isValid: Swift.Bool {
    get
  }
  public var generation: HealthCardAccess.CardGeneration? {
    get
  }
  public var type: HealthCardAccess.HealthCardPropertyType? {
    get
  }
}
extension HealthCardAccess.HealthCardStatus : Swift.Equatable {
  public static func == (lhs: HealthCardAccess.HealthCardStatus, rhs: HealthCardAccess.HealthCardStatus) -> Swift.Bool
}
public protocol HealthCardType {
  var status: HealthCardAccess.HealthCardStatus { get }
  var currentCardChannel: any CardReaderProviderApi.CardChannelType { get }
}
extension HealthCardAccess.HealthCardType {
  public func disconnect(reset: Swift.Bool) throws
}
public struct Key : HealthCardAccess.CardItemType, HealthCardAccess.CardKeyReferenceType {
  public enum Error : Swift.Error, Swift.Equatable {
    case illegalArgument(Swift.String)
    public static func == (a: HealthCardAccess.Key.Error, b: HealthCardAccess.Key.Error) -> Swift.Bool
  }
  public let keyId: Swift.UInt8
  public init(_ key: Swift.UInt8) throws
  public func calculateKeyReference(dfSpecific: Swift.Bool) -> Swift.UInt8
  public static func == (a: HealthCardAccess.Key, b: HealthCardAccess.Key) -> Swift.Bool
}
public enum PSOAlgorithm {
  case aesSessionKey4SM
  case desSessionKey4SM
  case aesSessionKey4TC
  case desSessionKey4TC
  case elcAsyncAdmin
  case elcRoleAuthentication
  case elcRoleCheck
  case elcSessionKey4SM
  case elcSessionKey4TC
  case rsaClientAuthentication
  case rsaRoleAuthenticationOptionCVC
  case rsaRoleCheckOptionCVC
  case rsaSessionKey4SMOptionDES
  case rsaSessionKey4TCOptionDES
  case aesSessionKey
  case desSessionKey
  case rsaDecipherOAEP
  case rsaDecipherPKCS1v15
  case rsaEncipherOAEP
  case rsaEncipherPKCS1v15
  case elcSharedSecretCalculation
  case sign9796v2DS2
  case signPKCS1v15
  case signPSS
  case signECDSA
  public var identifier: Swift.UInt8 {
    get
  }
  public var name: Swift.String? {
    get
  }
  public static func == (a: HealthCardAccess.PSOAlgorithm, b: HealthCardAccess.PSOAlgorithm) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct Password : HealthCardAccess.CardItemType, HealthCardAccess.CardKeyReferenceType {
  public enum Error : Swift.Error, Swift.Equatable {
    case illegalArgument(Swift.String)
    public static func == (a: HealthCardAccess.Password.Error, b: HealthCardAccess.Password.Error) -> Swift.Bool
  }
  public let pwdId: Swift.UInt8
  public init(_ value: Swift.UInt8) throws
  public func calculateKeyReference(dfSpecific: Swift.Bool) -> Swift.UInt8
  public static func == (a: HealthCardAccess.Password, b: HealthCardAccess.Password) -> Swift.Bool
}
extension HealthCardAccess.Password : Swift.ExpressibleByStringLiteral {
  public typealias ExtendedGraphemeClusterLiteralType = HealthCardAccess.Password.StringLiteralType
  public typealias UnicodeScalarLiteralType = Swift.String
  public init(stringLiteral value: Swift.StringLiteralType)
  public init(extendedGraphemeClusterLiteral value: HealthCardAccess.Password.ExtendedGraphemeClusterLiteralType)
  public init(unicodeScalarLiteral value: HealthCardAccess.Password.UnicodeScalarLiteralType)
  public typealias StringLiteralType = Swift.StringLiteralType
}
public enum ResponseStatus {
  case success
  case unknownException
  case unknownStatus
  case dataTruncated
  case corruptDataWarning
  case endOfFileWarning
  case endOfRecordWarning
  case unsuccessfulSearch
  case fileDeactivated
  case fileTerminated
  case recordDeactivated
  case transportStatusTransportPin
  case transportStatusEmptyPin
  case passwordDisabled
  case authenticationFailure
  case noAuthentication
  case retryCounterCount00
  case retryCounterCount01
  case retryCounterCount02
  case retryCounterCount03
  case retryCounterCount04
  case retryCounterCount05
  case retryCounterCount06
  case retryCounterCount07
  case retryCounterCount08
  case retryCounterCount09
  case retryCounterCount10
  case retryCounterCount11
  case retryCounterCount12
  case retryCounterCount13
  case retryCounterCount14
  case retryCounterCount15
  case updateRetryWarningCount00
  case updateRetryWarningCount01
  case updateRetryWarningCount02
  case updateRetryWarningCount03
  case updateRetryWarningCount04
  case updateRetryWarningCount05
  case updateRetryWarningCount06
  case updateRetryWarningCount07
  case updateRetryWarningCount08
  case updateRetryWarningCount09
  case updateRetryWarningCount10
  case updateRetryWarningCount11
  case updateRetryWarningCount12
  case updateRetryWarningCount13
  case updateRetryWarningCount14
  case updateRetryWarningCount15
  case wrongSecretWarningCount00
  case wrongSecretWarningCount01
  case wrongSecretWarningCount02
  case wrongSecretWarningCount03
  case wrongSecretWarningCount04
  case wrongSecretWarningCount05
  case wrongSecretWarningCount06
  case wrongSecretWarningCount07
  case wrongSecretWarningCount08
  case wrongSecretWarningCount09
  case wrongSecretWarningCount10
  case wrongSecretWarningCount11
  case wrongSecretWarningCount12
  case wrongSecretWarningCount13
  case wrongSecretWarningCount14
  case wrongSecretWarningCount15
  case encipherError
  case keyInvalid
  case objectTerminated
  case parameterMismatch
  case memoryFailure
  case wrongRecordLength
  case channelClosed
  case noMoreChannelsAvailable
  case volatileKeyWithoutLcs
  case wrongFileType
  case securityStatusNotSatisfied
  case commandBlocked
  case keyExpired
  case passwordBlocked
  case keyAlreadyPresent
  case noKeyReference
  case noPrkReference
  case noPukReference
  case noRandom
  case noRecordLifeCycleStatus
  case passwordNotUsable
  case wrongRandomLength
  case wrongRandomOrNoKeyReference
  case wrongPasswordLength
  case noCurrentEf
  case incorrectSmDo
  case newFileSizeWrong
  case numberPreconditionWrong
  case numberScenarioWrong
  case verificationError
  case wrongCipherText
  case wrongToken
  case unsupportedFunction
  case fileNotFound
  case recordNotFound
  case dataTooBig
  case fullRecordList
  case messageTooLong
  case outOfMemory
  case fullRecordListOrOutOfMemory
  case inconsistentKeyReference
  case wrongKeyReference
  case keyNotFound
  case keyOrPrkNotFound
  case keyOrPwdNotFound
  case passwordNotFound
  case prkNotFound
  case pukNotFound
  case duplicatedObjects
  case dfNameExists
  case offsetTooBig
  case instructionNotSupported
  case customError
  public var code: Swift.UInt16 {
    get
  }
  public static func == (a: HealthCardAccess.ResponseStatus, b: HealthCardAccess.ResponseStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct ShortFileIdentifier : HealthCardAccess.CardObjectIdentifierType {
  public enum Error : Swift.Error, Swift.Equatable {
    case illegalArgument(Swift.String)
    public static func == (a: HealthCardAccess.ShortFileIdentifier.Error, b: HealthCardAccess.ShortFileIdentifier.Error) -> Swift.Bool
  }
  public let rawValue: Foundation.Data
  public static func isValid(_ value: Foundation.Data) -> Swift.Result<Foundation.Data, any Swift.Error>
  public static func isValid(_ value: Swift.UInt8) -> Swift.Result<Foundation.Data, any Swift.Error>
  public init(asn1 data: Foundation.Data) throws
  public init(hex text: Swift.String) throws
  public init(_ value: Swift.UInt8) throws
  public typealias StringLiteralType = Swift.StringLiteralType
}
extension HealthCardAccess.ShortFileIdentifier : Swift.CustomDebugStringConvertible, Swift.CustomStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
}
extension HealthCardAccess.ShortFileIdentifier {
  public typealias ExtendedGraphemeClusterLiteralType = HealthCardAccess.ShortFileIdentifier.StringLiteralType
  public typealias UnicodeScalarLiteralType = Swift.String
  public init(stringLiteral value: Swift.StringLiteralType)
  public init(extendedGraphemeClusterLiteral value: HealthCardAccess.ShortFileIdentifier.ExtendedGraphemeClusterLiteralType)
  public init(unicodeScalarLiteral value: HealthCardAccess.ShortFileIdentifier.UnicodeScalarLiteralType)
}
public enum SignatureAlgorithm {
  case ecdsaSha256
  case sha256RsaMgf1
  public static func == (a: HealthCardAccess.SignatureAlgorithm, b: HealthCardAccess.SignatureAlgorithm) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension HealthCardAccess.SignatureAlgorithm {
  public static func from(psoAlgorithm: HealthCardAccess.PSOAlgorithm) -> HealthCardAccess.SignatureAlgorithm?
}
public struct SmcbFileSystem {
}
extension HealthCardAccess.CardGeneration : Swift.Equatable {}
extension HealthCardAccess.CardGeneration : Swift.Hashable {}
extension HealthCardAccess.EgkFileSystem.Pin : Swift.Equatable {}
extension HealthCardAccess.EgkFileSystem.Pin : Swift.Hashable {}
extension HealthCardAccess.EgkFileSystem.Pin : Swift.RawRepresentable {}
extension HealthCardAccess.FileControlParameter.LifeCycleState : Swift.Hashable {}
extension HealthCardAccess.FileControlParameter.Tag : Swift.Equatable {}
extension HealthCardAccess.FileControlParameter.Tag : Swift.Hashable {}
extension HealthCardAccess.FileControlParameter.Tag : Swift.RawRepresentable {}
extension HealthCardAccess.HealthCardCommand.ManageSE.DomainId : Swift.Equatable {}
extension HealthCardAccess.HealthCardCommand.ManageSE.DomainId : Swift.Hashable {}
extension HealthCardAccess.HealthCardCommand.ManageSE.DomainId : Swift.RawRepresentable {}
extension HealthCardAccess.HealthCardCommand.Misc.ChallengeParameter : Swift.Equatable {}
extension HealthCardAccess.HealthCardCommand.Misc.ChallengeParameter : Swift.Hashable {}
extension HealthCardAccess.PSOAlgorithm : Swift.Equatable {}
extension HealthCardAccess.PSOAlgorithm : Swift.Hashable {}
extension HealthCardAccess.ResponseStatus : Swift.Equatable {}
extension HealthCardAccess.ResponseStatus : Swift.Hashable {}
extension HealthCardAccess.SignatureAlgorithm : Swift.Equatable {}
extension HealthCardAccess.SignatureAlgorithm : Swift.Hashable {}
